**4Sum**

**Problem Information**

- **Difficulty:** Medium
- **Category:** Two Pointers, Sorting
- **Companies:** Known companies that frequently ask this
- **Link:** https://leetcode.com/problems/4sum/

**Problem Statement**

Given an array of integers, find all unique quadruplets within the array that add up to the same value.

**Examples**

```markdown
Input: 4, 4, 4, 7, 7, 8, 8, 9
Output: [[1, 2, 3, 4], [4, 4, 4, 5], [1, 4, 7, 8], [2, 3, 7, 8], [1, 4, 7, 9], [2, 3, 8, 9]]
Explanation:
Given this array: [4, 4, 4, 7, 7, 8, 8, 9]
We can form four unique quadruplets: [1, 2, 3, 4], [4, 4, 4, 5], [1, 4, 7, 8], [2, 3, 7, 8], [1, 4, 7, 9], [2, 3, 8, 9]
```

### Constraints

- **Time Complexity:** O(N^3)
  - O(N^2) for two pointers
  - O(N) for sorting
- **Space Complexity:** O(1)
  - We only use a constant amount of space

### Solution Approach

We will use two pointers to achieve the solution. We start by sorting the array. Then we use the two pointers to form the first quadruplet. We use another two pointers to form the second quadruplet. We continue this process until we have formed four unique quadruplets.

### Complexity Analysis

- **Time Complexity:** O(N^3)
  - O(N^2) for two pointers
  - O(N) for sorting
- **Space Complexity:** O(1)
  - We only use a constant amount of space

### Code Implementation

```python
def fourSum(nums, target):
    nums.sort()
    result = []
    for i in range(len(nums) - 3):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        for j in range(i + 1, len(nums) - 2):
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue
            left, right = j + 1, len(nums) - 1
            while left < right:
                current_sum = nums[i] + nums[j] + nums[left] + nums[right]
                if current_sum < target:
                    left += 1
                elif current_sum > target:
                    right -= 1
                else:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
    return result
```

### Step-by-Step Explanation

1.  Sort the input array `nums`.
2.  Iterate through the array using two pointers, `i` and `j`. For each pair of pointers, consider all possible pairs of elements with the value at `nums[i]`.
3.  For each pair of elements, use another pair of pointers, `left` and `right`, to form the second quadruplet.
4.  Continue this process until all pairs of elements have been considered.
5.  Once all quadruplets have been formed, add them to the result list.

### Alternative Approaches

1.  **Brute Force Approach**: We can use the brute force approach to find all possible quadruplets by creating all possible pairs of elements and then checking if the sum of each pair is equal to the target.
2.  **Two Pointers with Hash Table**: We can use two pointers to find all possible pairs of elements. We can use a hash table to store the elements we have seen so far and their counts. This approach has a time complexity of O(N^2).
3.  **Sorting and Two Pointers**: We can sort the array and then use two pointers to find all possible quadruplets. This approach has a time complexity of O(N^2).

### Common Mistakes and Pitfalls

1.  **Inefficient Brute Force Approach**: The brute force approach has a time complexity of O(N^2) which is inefficient for large inputs.
2.  **Incorrect Hash Table Usage**: The hash table usage in the two pointers approach is incorrect. We should use a dictionary to store the elements we have seen so far and their counts.
3.  **Inefficient Sorting Approach**: The sorting approach has a time complexity of O(N^2) which is inefficient for large inputs.