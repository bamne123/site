"use strict";(self.webpackChunkmy_stie=self.webpackChunkmy_stie||[]).push([[8567],{8830:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>u});const o=JSON.parse('{"id":"leetcode/Easy/Two Sum","title":"Two Sum","description":"Input: nums = [2,7,11,15], target = 9","source":"@site/docs/leetcode/Easy/Two Sum.md","sourceDirName":"leetcode/Easy","slug":"/leetcode/Easy/Two Sum","permalink":"/site/docs/leetcode/Easy/Two Sum","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/leetcode/Easy/Two Sum.md","tags":[],"version":"current","frontMatter":{},"sidebar":"leetcodeSidebar","previous":{"title":"Welcome","permalink":"/site/docs/leetcode/sytem-design/intro"},"next":{"title":"Problem Title: 3 Sum Problem","permalink":"/site/docs/leetcode/test"}}');var s=t(4848),i=t(8453);const a={},r=void 0,l={},u=[{value:"Solution Explanation",id:"solution-explanation",level:2},{value:"LeetCode Official Solutions",id:"leetcode-official-solutions",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",children:"# Problem Title: Two Sum\n\n**Difficulty:** Easy\n\n**Tags:** Array, Hash Table\n\n**Problem Statement:**  \nGiven an array of integers `nums` and an integer `target`, return *indices of the two numbers such that they add up to `target`*.\n\nYou may assume that each input would have **exactly one solution**, and you may not use the *same* element twice.\n\nYou can return the answer in any order.\n\n**Example 1:**\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1]."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\n**Example 2:**\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"Input: nums = [3,2,4], target = 6\nOutput: [1,2]"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\n**Example 3:**\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"Input: nums = [3,3], target = 6\nOutput: [0,1]"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\n**Constraints:**\n\n* `2 <= nums.length <= 104`\n* `-109 <= nums[i] <= 109`\n* `-109 <= target <= 109`\n* **Only one valid answer exists.**\n\n\n**LeetCode Link:** https://leetcode.com/problems/two-sum\n\n## Explanation\nThe problem requires finding two numbers within a given array that sum up to a specified target value.  The output should be the indices of these two numbers.  For example, in the array `[2, 7, 11, 15]` with a target of `9`, the function should return `[0, 1]` because `nums[0] (2) + nums[1] (7) = 9`.  The challenge lies in efficiently finding this pair within the array.\n\n## Time & Space Complexity\n- **Time Complexity:** O(n) -  This is achieved using a hash table (dictionary in Python).  We iterate through the array once.\n- **Space Complexity:** O(n) - In the worst case, the hash table might store all elements of the input array.\n\n## Solution\n```python\ndef twoSum(nums, target):\n    num_map = {}  # Create a hash map to store numbers and their indices\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i  # Add the number and its index to the map\n\n"})}),"\n",(0,s.jsx)(n.h2,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,s.jsxs)(n.p,{children:["The solution uses a hash map (dictionary in Python) to store each number and its index.  It iterates through the ",(0,s.jsx)(n.code,{children:"nums"})," array. For each number, it calculates the ",(0,s.jsx)(n.code,{children:"complement"})," needed to reach the ",(0,s.jsx)(n.code,{children:"target"}),". It then checks if the ",(0,s.jsx)(n.code,{children:"complement"})," exists in the ",(0,s.jsx)(n.code,{children:"num_map"}),". If it does, it means we've found the pair, and we return their indices. Otherwise, it adds the current number and its index to the ",(0,s.jsx)(n.code,{children:"num_map"}),". This approach ensures a single pass through the array, resulting in O(n) time complexity."]}),"\n",(0,s.jsx)(n.h2,{id:"leetcode-official-solutions",children:"LeetCode Official Solutions"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/two-sum/solution/",children:"Official LeetCode Solution"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var o=t(6540);const s={},i=o.createContext(s);function a(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);