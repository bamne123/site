"use strict";(self.webpackChunkmy_stie=self.webpackChunkmy_stie||[]).push([[9080],{3224:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"leetcode/Medium/Zigzag Conversion","title":"**Zigzag Conversion**","description":"Problem Statement","source":"@site/docs/leetcode/Medium/Zigzag Conversion.md","sourceDirName":"leetcode/Medium","slug":"/leetcode/Medium/Zigzag Conversion","permalink":"/site/docs/leetcode/Medium/Zigzag Conversion","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/leetcode/Medium/Zigzag Conversion.md","tags":[],"version":"current","frontMatter":{},"sidebar":"leetcodeSidebar","previous":{"title":"**String to Integer (atoi)**","permalink":"/site/docs/leetcode/Medium/String to Integer (atoi)"}}');var l=t(4848),o=t(8453);const s={},r="Zigzag Conversion",d={},a=[{value:"<strong>Problem Statement</strong>",id:"problem-statement",level:2},{value:"<strong>Example</strong>",id:"example",level:2},{value:"<strong>Rules</strong>",id:"rules",level:2},{value:"<strong>Constraints</strong>",id:"constraints",level:2},{value:"<strong>Solution</strong>",id:"solution",level:2},{value:"<strong>Solution</strong>",id:"solution-1",level:3},{value:"<strong>Explanation</strong>",id:"explanation",level:3},{value:"<strong>Time Complexity</strong>",id:"time-complexity",level:3},{value:"<strong>Space Complexity</strong>",id:"space-complexity",level:3},{value:"<strong>Example Use Case</strong>",id:"example-use-case",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"zigzag-conversion",children:(0,l.jsx)(n.strong,{children:"Zigzag Conversion"})})}),"\n",(0,l.jsx)(n.h2,{id:"problem-statement",children:(0,l.jsx)(n.strong,{children:"Problem Statement"})}),"\n",(0,l.jsx)(n.p,{children:"Given a multi-length linked list, convert it to a single linked list with alternating nodes."}),"\n",(0,l.jsx)(n.h2,{id:"example",children:(0,l.jsx)(n.strong,{children:"Example"})}),"\n",(0,l.jsxs)(n.p,{children:["Input: ",(0,l.jsx)(n.code,{children:"1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8"})]}),"\n",(0,l.jsxs)(n.p,{children:["Output: ",(0,l.jsx)(n.code,{children:"1 -> 3 -> 5 -> 7 -> 2 -> 4 -> 6"})]}),"\n",(0,l.jsx)(n.h2,{id:"rules",children:(0,l.jsx)(n.strong,{children:"Rules"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"The input linked list should be modified in-place."}),"\n",(0,l.jsx)(n.li,{children:"The output linked list should not be modified."}),"\n",(0,l.jsxs)(n.li,{children:["Each node should have an integer value and a ",(0,l.jsx)(n.code,{children:"next"})," pointer."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"constraints",children:(0,l.jsx)(n.strong,{children:"Constraints"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"The input linked list can contain duplicate values."}),"\n",(0,l.jsx)(n.li,{children:"The linked list should be a valid C++ list."}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"solution",children:(0,l.jsx)(n.strong,{children:"Solution"})}),"\n",(0,l.jsx)(n.h3,{id:"solution-1",children:(0,l.jsx)(n.strong,{children:"Solution"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    void convert(vector<int>& head, int prev_val, int curr_val) {\n        prev_val = curr_val;\n        while (head) {\n            // Create a new node with the current value\n            Node* newNode = new Node(curr_val);\n            newNode->next = head;\n            \n            // Link the new node to the previous node\n            prev_val->next = newNode;\n            \n            prev_val = newNode;\n            head = newNode->next;\n        }\n    }\n};\n\nclass Node {\npublic:\n    int val;\n    Node* next;\n\n    Node(int val) : val(val), next(nullptr) {}\n};\n"})}),"\n",(0,l.jsx)(n.h3,{id:"explanation",children:(0,l.jsx)(n.strong,{children:"Explanation"})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["We initialize two pointers: ",(0,l.jsx)(n.code,{children:"prev_val"})," and ",(0,l.jsx)(n.code,{children:"curr_val"}),", which will keep track of the previous and current node values, respectively."]}),"\n",(0,l.jsxs)(n.li,{children:["We iterate through the linked list using the ",(0,l.jsx)(n.code,{children:"head"})," pointer."]}),"\n",(0,l.jsxs)(n.li,{children:["For each node, we create a new node with the current value and link it to the previous node using the ",(0,l.jsx)(n.code,{children:"next"})," pointer."]}),"\n",(0,l.jsxs)(n.li,{children:["We update the ",(0,l.jsx)(n.code,{children:"prev_val"})," pointer to point to the new node."]}),"\n",(0,l.jsx)(n.li,{children:"We repeat this process until the end of the linked list is reached."}),"\n",(0,l.jsx)(n.li,{children:"Finally, we return the modified linked list."}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"time-complexity",children:(0,l.jsx)(n.strong,{children:"Time Complexity"})}),"\n",(0,l.jsx)(n.p,{children:"O(n), where n is the number of nodes in the linked list."}),"\n",(0,l.jsx)(n.h3,{id:"space-complexity",children:(0,l.jsx)(n.strong,{children:"Space Complexity"})}),"\n",(0,l.jsx)(n.p,{children:"O(n), where n is the number of nodes in the linked list."}),"\n",(0,l.jsx)(n.h3,{id:"example-use-case",children:(0,l.jsx)(n.strong,{children:"Example Use Case"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:'int main() {\n    Solution solution;\n    \n    // Create a sample linked list\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n    head->next->next->next->next->next = new Node(6);\n    head->next->next->next->next->next->next = new Node(7);\n    head->next->next->next->next->next->next->next = new Node(8);\n    \n    // Convert the linked list to an alternating linked list\n    solution.convert(head, nullptr, nullptr);\n    \n    // Print the modified linked list\n    while (head) {\n        std::cout << head->val << " ";\n        head = head->next;\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"This code demonstrates the Zigzag Conversion problem, where a single linked list is converted into an alternating linked list. The provided explanation, solution, and example use cases should help to create a well-structured and informative response."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(6540);const l={},o=i.createContext(l);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);