"use strict";(self.webpackChunkmy_stie=self.webpackChunkmy_stie||[]).push([[4712],{8213:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"leetcode/Hard/Median of Two Sorted Arrays","title":"Median of Two Sorted Arrays","description":"Median of Two Sorted Arrays","source":"@site/docs/leetcode/Hard/4-Median of Two Sorted Arrays.md","sourceDirName":"leetcode/Hard","slug":"/leetcode/Hard/Median of Two Sorted Arrays","permalink":"/site/docs/leetcode/Hard/Median of Two Sorted Arrays","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/leetcode/Hard/4-Median of Two Sorted Arrays.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"leetcodeSidebar","previous":{"title":"Roman to Integer","permalink":"/site/docs/leetcode/Easy/Roman to Integer"},"next":{"title":"Regular Expression Matching","permalink":"/site/docs/leetcode/Hard/Regular Expression Matching"}}');var i=t(4848),r=t(8453);const l={},o=void 0,a={},d=[{value:"Problem Statement",id:"problem-statement",level:3},{value:"Examples",id:"examples",level:3},{value:"Solution",id:"solution",level:3},{value:"Time and Space Complexity",id:"time-and-space-complexity",level:3}];function c(e){const n={code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Median of Two Sorted Arrays"})}),"\n",(0,i.jsx)(n.h3,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(n.p,{children:["Given two sorted arrays, ",(0,i.jsx)(n.code,{children:"nums1"})," and ",(0,i.jsx)(n.code,{children:"nums2"}),", where ",(0,i.jsx)(n.code,{children:"nums1"})," is the first sorted array and ",(0,i.jsx)(n.code,{children:"nums2"})," is the second sorted array, return the median of the two arrays combined. If one of the arrays is shorter than the other, the missing elements are filled in ascending order."]}),"\n",(0,i.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input:"})," ",(0,i.jsx)(n.code,{children:"nums1 = [1, 2, 3], nums2 = [4, 5, 6, 7]"}),"\n",(0,i.jsx)(n.strong,{children:"Output:"})," ",(0,i.jsx)(n.code,{children:"4"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= nums1.length <= 50000"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= nums2.length <= 50000"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"-1000000000 <= nums1[i] <= 1000000000"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"-1000000000 <= nums2[i] <= 1000000000"})}),"\n",(0,i.jsxs)(n.li,{children:["All elements in ",(0,i.jsx)(n.code,{children:"nums1"})," and ",(0,i.jsx)(n.code,{children:"nums2"})," are unique."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"nums1"})," and ",(0,i.jsx)(n.code,{children:"nums2"})," are sorted arrays."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"solution",children:"Solution"}),"\n",(0,i.jsx)(n.p,{children:"You can solve this problem using a two-pointer technique. The time complexity is O(log(min(n, m))), where n and m are the lengths of the two input arrays."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def findMedianSortedArrays(nums1, nums2):\n    # Make sure nums1 is the smaller array\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    # Calculate the total length\n    total_length = len(nums1) + len(nums2)\n\n    # Check if the total length is odd or even\n    half_length = total_length // 2\n\n    # Initialize the binary search range\n    left = 0\n    right = len(nums1) - 1\n\n    while True:\n        # Calculate the partition point for nums1\n        i = (left + right) // 2\n        j = half_length - i - 2\n\n        # Calculate the corresponding partition point for nums2\n        k = i\n        if j < 0:\n            # If j is negative, nums2 is all elements\n            # Simply return the average of the elements in nums1 and nums2\n            return (min(nums1[i], nums2[k]) + max(nums1[i], nums2[k])) / 2\n\n        # If i is too small, move the left pointer\n        if i - left < 0:\n            # If j is negative, nums1 is all elements\n            return (min(nums1[left], nums2[j + 1])) if nums1[left] < nums2[j + 1] else max(nums1[left], nums2[j + 1])\n\n        # If j is too small, move the right pointer\n        if j - j - 1 < 0:\n            # If i is negative, nums2 is all elements\n            return (min(nums1[i], nums2[left])) if nums1[i] < nums2[left] else max(nums1[i], nums2[left])\n\n        # If i is too large, move the left pointer\n        if nums1[i] > nums2[j + 1]:\n            right = i - 1\n        elif nums1[i] < nums2[j + 1]:\n            left = i + 1\n        else:\n            # If the partition point is correct, calculate the total length and return the median\n            return (min(nums1[i], nums2[j + 1]) + max(nums1[i], nums2[j + 1])) / 2\n"})}),"\n",(0,i.jsx)(n.h3,{id:"time-and-space-complexity",children:"Time and Space Complexity"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Time complexity: O(log(min(n, m)))"}),"\n",(0,i.jsx)(n.li,{children:"Space complexity: O(1)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Note that the binary search range is used to find the partition point for each array, and the final step is to calculate the median as the average of the elements in the two arrays."})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function l(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);