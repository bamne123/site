"use strict";(self.webpackChunkmy_stie=self.webpackChunkmy_stie||[]).push([[6347],{7332:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"leetcode/Medium/Longest Palindromic Substring","title":"**Problem Title: Longest Palindromic Substring**","description":"Difficulty: Medium","source":"@site/docs/leetcode/Medium/Longest Palindromic Substring.md","sourceDirName":"leetcode/Medium","slug":"/leetcode/Medium/Longest Palindromic Substring","permalink":"/site/docs/leetcode/Medium/Longest Palindromic Substring","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/leetcode/Medium/Longest Palindromic Substring.md","tags":[],"version":"current","frontMatter":{},"sidebar":"leetcodeSidebar","previous":{"title":"**Add Two Numbers**","permalink":"/site/docs/leetcode/Medium/Add Two Numbers"},"next":{"title":"Longest Substring Without Repeating Characters","permalink":"/site/docs/leetcode/Medium/Longest Substring Without Repeating Characters"}}');var r=t(4848),s=t(8453);const o={},l="Problem Title: Longest Palindromic Substring",a={},d=[{value:"Solution",id:"solution",level:2},{value:"Solution Explanation",id:"solution-explanation",level:2},{value:"LeetCode Official Solutions",id:"leetcode-official-solutions",level:2},{value:"Additional Features",id:"additional-features",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"problem-title-longest-palindromic-substring",children:(0,r.jsx)(n.strong,{children:"Problem Title: Longest Palindromic Substring"})})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Difficulty:"})," Medium"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tags:"})," Two Pointers, String, Dynamic Programming"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem Statement:"}),"\nGiven a string ",(0,r.jsx)(n.code,{children:"s"}),", return the longest palindromic substring within the string. If there are multiple palindromic substrings, return the longest one."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example:"}),'\nInput: "babad"\nOutput: "bab"']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),'\nThe longest palindromic substring is "bab" because it is the longest substring that reads the same forwards and backwards.']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"}),"\nO(n^2) where n is the length of the string."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity:"}),"\nO(n) where n is the length of the string."]}),"\n",(0,r.jsx)(n.h2,{id:"solution",children:"Solution"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def longest_palindromic_substring(s: str) -> str:\n    """\n    Returns the longest palindromic substring within the given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: The longest palindromic substring.\n    """\n    \n    def expand_around_center(left: int, right: int) -> str:\n        """\n        Expands around the center of the palindrome to find the longest palindromic substring.\n        \n        Args:\n        left (int): The left index of the center.\n        right (int): The right index of the center.\n        \n        Returns:\n        str: The longest palindromic substring.\n        """\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n    \n    longest_palindrome = ""\n    \n    # Iterate over the string to find the longest palindromic substring\n    for i in range(len(s)):\n        palindrome1 = expand_around_center(i, i)\n        palindrome2 = expand_around_center(i, i + 1)\n        \n        # Update the longest palindromic substring if necessary\n        if len(palindrome1) > len(longest_palindrome):\n            longest_palindrome = palindrome1\n        if len(palindrome2) > len(longest_palindrome):\n            longest_palindrome = palindrome2\n    \n    return longest_palindrome\n'})}),"\n",(0,r.jsx)(n.h2,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,r.jsxs)(n.p,{children:["The solution uses a helper function ",(0,r.jsx)(n.code,{children:"expand_around_center"})," to expand around the center of the palindrome to find the longest palindromic substring. It iterates over the string, treating each character as the center of a potential palindrome, and then checks all neighboring characters to see if they are also part of the palindrome. The function returns the longest palindromic substring found."]}),"\n",(0,r.jsxs)(n.p,{children:["The main function then iterates over the string, calling ",(0,r.jsx)(n.code,{children:"expand_around_center"})," for each character to find the longest palindromic substring. It updates the ",(0,r.jsx)(n.code,{children:"longest_palindrome"})," variable if a longer palindromic substring is found."]}),"\n",(0,r.jsx)(n.h2,{id:"leetcode-official-solutions",children:"LeetCode Official Solutions"}),"\n",(0,r.jsx)(n.p,{children:"For the given problem, LeetCode provides an official solution that uses dynamic programming to find the longest palindromic substring. The solution has the same time and space complexity as the provided solution."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def longest_palindromic_substring(s: str) -> str:\n    def expand_around_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    longest_palindrome = ""\n    for i in range(len(s)):\n        palindrome1 = expand_around_center(i, i)\n        palindrome2 = expand_around_center(i, i + 1)\n        if len(palindrome1) > len(longest_palindrome):\n            longest_palindrome = palindrome1\n        if len(palindrome2) > len(longest_palindrome):\n            longest_palindrome = palindrome2\n\n    return longest_palindrome\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This official solution uses two nested loops to iterate over the string and call the ",(0,r.jsx)(n.code,{children:"expand_around_center"})," function for each character. It then updates the ",(0,r.jsx)(n.code,{children:"longest_palindrome"})," variable if a longer palindromic substring is found."]}),"\n",(0,r.jsx)(n.h3,{id:"additional-features",children:"Additional Features"}),"\n",(0,r.jsx)(n.p,{children:"The provided solution does not handle cases where the input string is empty or contains only one character. It also does not handle cases where the input string contains multiple palindromic substrings."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var i=t(6540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);