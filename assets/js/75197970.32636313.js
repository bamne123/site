"use strict";(self.webpackChunkmy_stie=self.webpackChunkmy_stie||[]).push([[776],{4533:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"leetcode/Hard/Regular Expression Matching","title":"Regular Expression Matching","description":"Regular Expression Matching","source":"@site/docs/leetcode/Hard/Regular Expression Matching.md","sourceDirName":"leetcode/Hard","slug":"/leetcode/Hard/Regular Expression Matching","permalink":"/site/docs/leetcode/Hard/Regular Expression Matching","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/leetcode/Hard/Regular Expression Matching.md","tags":[],"version":"current","frontMatter":{},"sidebar":"leetcodeSidebar","previous":{"title":"Median of Two Sorted Arrays","permalink":"/site/docs/leetcode/Hard/Median of Two Sorted Arrays"},"next":{"title":"3Sum Closest","permalink":"/site/docs/leetcode/Medium/3Sum Closest"}}');var s=t(4848),i=t(8453);const o={},a=void 0,c={},d=[{value:"<strong>Solution in Markdown:</strong>",id:"solution-in-markdown",level:3}];function p(e){const n={code:"code",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Regular Expression Matching"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem Statement:"}),"\nGiven a string ",(0,s.jsx)(n.code,{children:"s"})," and a pattern ",(0,s.jsx)(n.code,{children:"p"}),", return ",(0,s.jsx)(n.code,{children:"true"})," if ",(0,s.jsx)(n.code,{children:"s"})," matches ",(0,s.jsx)(n.code,{children:"p"}),", ",(0,s.jsx)(n.code,{children:"false"})," otherwise."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example 1:"}),"\nInput: ",(0,s.jsx)(n.code,{children:'s = "ab", p = "ab"'})," Output: ",(0,s.jsx)(n.code,{children:"true"}),"\nExplanation: Both strings are equal, so they match."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example 2:"}),"\nInput: ",(0,s.jsx)(n.code,{children:'s = "ab", p = "a"'})," Output: ",(0,s.jsx)(n.code,{children:"false"}),"\nExplanation: String ",(0,s.jsx)(n.code,{children:"s"})," does not contain substring ",(0,s.jsx)(n.code,{children:"p"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example 3:"}),"\nInput: ",(0,s.jsx)(n.code,{children:'s = "ab", p = "b"'})," Output: ",(0,s.jsx)(n.code,{children:"false"}),"\nExplanation: String ",(0,s.jsx)(n.code,{children:"s"})," does not contain substring ",(0,s.jsx)(n.code,{children:"p"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example 4:"}),"\nInput: ",(0,s.jsx)(n.code,{children:'s = "", p = "ab"'})," Output: ",(0,s.jsx)(n.code,{children:"true"}),"\nExplanation: An empty string matches any string."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Time Complexity:"}),"\nThe time complexity of this solution is O(n*m), where n is the length of the string ",(0,s.jsx)(n.code,{children:"s"})," and m is the length of the pattern ",(0,s.jsx)(n.code,{children:"p"}),". This is because we need to iterate over both the string and the pattern to determine if they match."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Space Complexity:"}),"\nThe space complexity of this solution is O(1), as we only need a constant amount of space to store the input string and pattern."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Solution:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def isSubsequence(s: str, p: str) -> bool:\n    """\n    Returns true if s matches p, false otherwise.\n    \n    :param s: Input string\n    :param p: Pattern string\n    :return: bool\n    """\n    # Initialize two pointers to keep track of the current position in s and p\n    s_pointer = 0\n    p_pointer = 0\n    \n    # Iterate over the string p\n    while p_pointer < len(p):\n        # If the current character in p matches the current character in s\n        if p_pointer < len(p) and p[p_pointer] == s[s_pointer]:\n            # Move the pointer in s forward\n            s_pointer += 1\n        # Move the pointer in p forward\n        p_pointer += 1\n    \n    # If we have iterated over the entire string, they match\n    return s_pointer == len(s)\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Explanation:"}),"\nWe use two pointers, ",(0,s.jsx)(n.code,{children:"s_pointer"})," and ",(0,s.jsx)(n.code,{children:"p_pointer"}),", to keep track of the current position in the string ",(0,s.jsx)(n.code,{children:"s"})," and pattern ",(0,s.jsx)(n.code,{children:"p"}),", respectively. We iterate over the string ",(0,s.jsx)(n.code,{children:"p"})," and move the ",(0,s.jsx)(n.code,{children:"s_pointer"})," forward whenever we find a match between the current character in ",(0,s.jsx)(n.code,{children:"p"})," and the current character in ",(0,s.jsx)(n.code,{children:"s"}),". If we reach the end of the string ",(0,s.jsx)(n.code,{children:"s"}),", it means they match, and we return ",(0,s.jsx)(n.code,{children:"True"}),". If we don't reach the end of the string ",(0,s.jsx)(n.code,{children:"s"})," after iterating over the entire string, it means they don't match, and we return ",(0,s.jsx)(n.code,{children:"False"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"solution-in-markdown",children:(0,s.jsx)(n.strong,{children:"Solution in Markdown:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-md",children:'# Regular Expression Matching Problem\n\n**Problem Description:**\nGiven a string `s` and a pattern `p`, return `true` if `s` matches `p`, `false` otherwise.\n\n## Example Use Cases\n\n* `s = "ab", p = "ab"` Output: `true`\n* `s = "ab", p = "a"` Output: `false`\n* `s = "ab", p = "b"` Output: `false`\n* `s = "", p = "ab"` Output: `true`\n\n## Time Complexity\n\n* O(n*m)\n\n## Space Complexity\n\n* O(1)\n\n## Solution\n```python\ndef isSubsequence(s: str, p: str) -> bool:\n    """\n    Returns true if s matches p, false otherwise.\n    \n    :param s: Input string\n    :param p: Pattern string\n    :return: bool\n    """\n    # Initialize two pointers to keep track of the current position in s and p\n    s_pointer = 0\n    p_pointer = 0\n    \n    # Iterate over the string p\n    while p_pointer < len(p):\n        # If the current character in p matches the current character in s\n        if p_pointer < len(p) and p[p_pointer] == s[s_pointer]:\n            # Move the pointer in s forward\n            s_pointer += 1\n        # Move the pointer in p forward\n        p_pointer += 1\n    \n    # If we have iterated over the entire string, they match\n    return s_pointer == len(s)\n'})})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);