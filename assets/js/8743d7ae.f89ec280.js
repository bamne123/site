"use strict";(self.webpackChunkmy_stie=self.webpackChunkmy_stie||[]).push([[282],{3455:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"leetcode/Medium/Zigzag Conversion","title":"**Zigzag Conversion**","description":"Problem Information","source":"@site/docs/leetcode/Medium/6-Zigzag Conversion.md","sourceDirName":"leetcode/Medium","slug":"/leetcode/Medium/Zigzag Conversion","permalink":"/site/docs/leetcode/Medium/Zigzag Conversion","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/leetcode/Medium/6-Zigzag Conversion.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"leetcodeSidebar","previous":{"title":"**Longest Palindromic Substring**","permalink":"/site/docs/leetcode/Medium/Longest Palindromic Substring"},"next":{"title":"Reverse Integer","permalink":"/site/docs/leetcode/Medium/Reverse Integer"}}');var r=t(4848),o=t(8453);const s={},l="Zigzag Conversion",d={},a=[{value:"<strong>Problem Information</strong>",id:"problem-information",level:2},{value:"Problem Statement",id:"problem-statement",level:3},{value:"Examples",id:"examples",level:3},{value:"Step-by-Step Explanation",id:"step-by-step-explanation",level:3},{value:"Complexity Analysis",id:"complexity-analysis",level:3},{value:"Code Implementation",id:"code-implementation",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"zigzag-conversion",children:(0,r.jsx)(n.strong,{children:"Zigzag Conversion"})})}),"\n",(0,r.jsx)(n.h2,{id:"problem-information",children:(0,r.jsx)(n.strong,{children:"Problem Information"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Difficulty:"})," Medium"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Category:"})," Array, String, Two Pointers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Companies:"})," None"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Link:"})," ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/zigzag-conversion/",children:"Zigzag Conversion"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,r.jsxs)(n.p,{children:["Given a linked list of ",(0,r.jsx)(n.code,{children:"n"})," elements, find the conversion of the linked list to a string representation, with alternating digits from left to right and right to left. If the input linked list is empty, return an empty string."]}),"\n",(0,r.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-markdown"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'Input: [1, 2, 3, 4, 5]\nOutput: "1234"\nExplanation:\nAlternate digits from left to right and right to left.'}),"\n",(0,r.jsx)(n.p,{children:'Input: [0]\nOutput: "0"\nExplanation:\nNo conversion required.'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'\n### Constraints\n\n*   The linked list can have any number of nodes.\n*   The input linked list is guaranteed to be valid.\n\n### Solution Approach\n\n*   We will use two pointers, one at the beginning and one at the end of the linked list. We will alternate between these two pointers at the end of each iteration of the while loop. This will ensure that the digits from the left end are alternately seen and from the right end are alternately seen.\n\n### Solution Code\n\n```markdown\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def zigzagConversion(self, head: ListNode) -> str:\n        """\n        Convert the given linked list to a string representation,\n        with alternating digits from left to right and right to left.\n        \n        Args:\n        head (ListNode): The head of the linked list.\n        \n        Returns:\n        str: The conversion of the linked list to a string representation.\n        """\n        res = ""\n        prev, curr = None, head\n        while curr:\n            # Store the value of the current node\n            val = curr.val\n            # Append the value to the result string\n            res += str(val)\n            # Alternate the direction of the pointer\n            if prev:\n                prev.next = curr.next\n            else:\n                prev = curr\n            # Move to the next node\n            curr = curr.next\n        return res\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-by-step-explanation",children:"Step-by-Step Explanation"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Initialize two pointers, ",(0,r.jsx)(n.code,{children:"prev"})," and ",(0,r.jsx)(n.code,{children:"curr"}),", to the head of the linked list."]}),"\n",(0,r.jsxs)(n.li,{children:["Initialize an empty result string ",(0,r.jsx)(n.code,{children:"res"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["While the current node is not ",(0,r.jsx)(n.code,{children:"None"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Append the value of the current node to ",(0,r.jsx)(n.code,{children:"res"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Alternate the direction of the pointer by storing the next node in ",(0,r.jsx)(n.code,{children:"prev"})," and setting ",(0,r.jsx)(n.code,{children:"prev"})," to the current node."]}),"\n",(0,r.jsxs)(n.li,{children:["Move to the next node by setting ",(0,r.jsx)(n.code,{children:"curr"})," to the next node."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Return the result string ",(0,r.jsx)(n.code,{children:"res"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"complexity-analysis",children:"Complexity Analysis"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Time complexity: O(n), where n is the number of nodes in the linked list."}),"\n",(0,r.jsx)(n.li,{children:"Space complexity: O(n), where n is the number of nodes in the linked list."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"code-implementation",children:"Code Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class Solution:\n    def zigzagConversion(self, head: ListNode) -> str:\n        """\n        Convert the given linked list to a string representation,\n        with alternating digits from left to right and right to left.\n        \n        Args:\n        head (ListNode): The head of the linked list.\n        \n        Returns:\n        str: The conversion of the linked list to a string representation.\n        """\n        res = ""\n        prev, curr = None, head\n        while curr:\n            # Store the value of the current node\n            val = curr.val\n            # Append the value to the result string\n            res += str(val)\n            # Alternate the direction of the pointer\n            if prev:\n                prev.next = curr.next\n            else:\n                prev = curr\n            # Move to the next node\n            curr = curr.next\n        return res\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(6540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);